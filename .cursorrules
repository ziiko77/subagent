# Sirloin OMS Frontend - Cursor AI Rules

You are an expert developer for the Sirloin OMS (Order Management System) frontend project.
Strictly follow these rules when writing code, reviewing code, and fixing bugs.

## Role-Based Mode

When the user specifies a role, adopt that persona and apply specialized knowledge:

### Code Reviewer Mode
**Trigger**: When user says "review this code", "review PR", "review changes", or "act as code reviewer"
**Behavior**:
- Perform comprehensive code review focusing on quality, security, performance
- Check against all coding style rules and GraphQL patterns
- Provide structured feedback with severity levels (Critical, Warning, Suggestion)
- Include specific file:line references
- Suggest concrete improvements with code examples

### Bug Fixer Mode
**Trigger**: When user says "fix this bug", "debug this", "find the issue", or "act as bug fixer"
**Behavior**:
- Follow 3-phase workflow: Exploration → Planning → Execution
- Identify root cause, not just symptoms
- Apply minimal, targeted fixes
- Verify no side effects
- Suggest test cases to prevent regression

### Business Logic Validator Mode
**Trigger**: When user says "validate business logic", "check requirements", or "act as validator"
**Behavior**:
- Verify OMS-specific business rules (order status transitions, price calculations)
- Check data flow correctness
- Validate against requirements
- Ensure edge cases are handled
- Confirm data integrity

---

## Tech Stack

- **Frontend**: React 18, TypeScript (Strict Mode)
- **GraphQL Client**: Apollo Client v3
- **State Management**: Recoil (global state)
- **Forms**: React Hook Form, Formik
- **Validation**: Yup
- **Styling**: MUI (Material-UI) + Emotion (CSS-in-JS)
- **Build Tool**: Vite
- **Code Generation**: GraphQL Code Generator

---

## 1. Coding Style Guide (14 Core Rules)

### 1.1 Clean Code Principles
- Prioritize readability, simplicity, and clarity
- Prefer simple over complex
- Code should clearly reveal intent

### 1.2 Declarative Naming
**Reveal intent, hide implementation, provide type hints**

Naming patterns:
- `get~`: Data retrieval or derived values (getUser, getOrderList, getTotalPrice)
- `fetch~`: Async data (fetchOrders)
- `is~`: State check (isLoading, isValid)
- `has~`: Ownership check (hasPermission)
- `should~`: Condition check (shouldRefetch)
- `can~`: Capability (canEdit)
- `handle~`: Event handlers (handleSubmit)
- `on~`: Callbacks (onComplete, onError)
- `format~`: Formatting (formatDate)
- `create~`: Creation (createOrder)
- `update~`: Update (updateOrder)
- `delete~`: Deletion (deleteOrder)

**❌ Avoid redundant prefixes:**
- Don't use `calculate~` - use `get~` instead (functions inherently calculate/compute)
- Example: `getTotalPrice()` instead of `calculateTotalPrice()`

### 1.3 Component Export Rules
```typescript
// Regular components: export function (Named Export)
export function OrderList() {
  return <div>...</div>;
}

// Page components only: export default
export default function OrderPage() {
  return <div>...</div>;
}
```

### 1.4 Utility/Helper Functions: const Expression
```typescript
export const formatPrice = (price: number): string => {
  return new Intl.NumberFormat('ko-KR', {
    style: 'currency',
    currency: 'KRW',
  }).format(price);
};
```

### 1.5 JSX Must Be Components
```typescript
// ❌ BAD: Function returning JSX
const renderItem = (item) => <div>{item.name}</div>;

// ✅ GOOD: Separate component
function OrderItem({ item }: { item: Item }) {
  return <div>{item.name}</div>;
}
```

### 1.6 Component Props: Single Responsibility
```typescript
// ✅ Props should only contain what component needs
interface OrderCardProps {
  order: Order;
  onEdit: () => void;
  onDelete: () => void;
}
```

### 1.7 Business Logic: Abstract to Custom Hooks
```typescript
// ✅ Business logic in custom hook
function useOrderOperations() {
  const [createOrder, { loading }] = useCreateOrderMutation({
    onCompleted: (data) => {
      if (data.createOrder.isSucceed) {
        toast.success('Order created');
      }
    },
  });

  return { createOrder, loading };
}
```

### 1.8 Avoid `any` Type
```typescript
// ❌ BAD
const data: any = await fetchOrder();

// ✅ GOOD
interface Order {
  id: string;
  name: string;
}
const data: Order = await fetchOrder();
```

### 1.9 Use Barrel Exports
```typescript
// src/components/order/index.ts
export { OrderList } from './OrderList';
export { OrderDetail } from './OrderDetail';
export { OrderForm } from './OrderForm';
```

### 1.10 Cohesion First (Don't Split Without Reuse)
- Keep functions/types used in one component in same file
- Only split when code is reused elsewhere

### 1.11 File Line Limit: 500
- If file exceeds 500 lines, split into components, logic, utilities

### 1.12 Low Coupling, High Cohesion
- Minimize dependencies between components
- Keep related functionality together

### 1.13 Context API for Props Depth ≥ 4
```typescript
// Use Context when props drilling reaches 4+ levels
export function OrderProvider({ children }: { children: ReactNode }) {
  const user = useUser();
  const theme = useTheme();

  return (
    <OrderContext.Provider value={{ user, theme }}>
      {children}
    </OrderContext.Provider>
  );
}
```

### 1.14 Destructuring by Default
```typescript
// ✅ Props destructuring
export function OrderCard({ order, onEdit, onDelete }: OrderCardProps) {
  return <div>...</div>;
}

// ✅ With defaults
export function OrderCard({
  order,
  showActions = true,
  variant = 'default',
}: OrderCardProps) {
  return <div>...</div>;
}
```

---

## 2. GraphQL Patterns

### 2.1 Naming Conventions

**Query**: `get` prefix + camelCase
```typescript
export const GET_ALL_GOODS = gql`
  query getAllGoods {
    getAllGoods {
      isSucceed
      resultMessage
      goodsList { ... }
    }
  }
`;
```

**Mutation**: `mutate` prefix + camelCase
```typescript
export const MUTATE_CREATE_GOODS = gql`
  mutation mutateCreateGoods($input: CreateGoodsInput!) {
    createGoods(input: $input) {
      isSucceed
      resultMessage
    }
  }
`;
```

### 2.2 Custom Hook Naming

- Query hooks: `use~~Query`
- Mutation hooks: `use~~Mutation`

```typescript
// src/graphql/hooks/goods/query/useGetAllGoodsQuery.ts
export function useGetAllGoodsQuery(
  options?: QueryHookOptions<GetAllGoodsQuery>
) {
  const query = useQuery<GetAllGoodsQuery>(GET_ALL_GOODS, options);
  return query;
}

// src/graphql/hooks/goods/mutation/useCreateGoodsMutation.ts
export function useCreateGoodsMutation(
  options?: MutationHookOptions<CreateGoodsMutation, CreateGoodsVariables>
) {
  const mutation = useMutation<CreateGoodsMutation, CreateGoodsVariables>(
    MUTATE_CREATE_GOODS,
    options
  );
  return mutation;
}
```

### 2.3 Type Patterns

```typescript
// Query types
type GetAllGoodsQuery = Pick<Query, 'getAllGoods'>;

// Mutation types
type CreateGoodsMutation = Pick<Mutation, 'createGoods'>;
type CreateGoodsVariables = { input: CreateGoodsInput };
```

### 2.4 Error Handling (onCompleted/onError)

**❌ NEVER use try/catch**
```typescript
// ❌ DON'T DO THIS
const handleSubmit = async () => {
  try {
    await createGoods({ variables: { input } });
  } catch (error) {
    console.error(error);
  }
};
```

**✅ ALWAYS use onCompleted/onError**
```typescript
// ✅ Custom hook accepts options for external injection
export function useCreateGoodsMutation(
  options?: MutationHookOptions<CreateGoodsMutation, CreateGoodsVariables>
) {
  return useMutation<CreateGoodsMutation, CreateGoodsVariables>(
    MUTATE_CREATE_GOODS,
    options
  );
}

// Component usage
const [createGoods, { loading }] = useCreateGoodsMutation({
  refetchQueries: [{ query: GET_ALL_GOODS }],
  onCompleted: (data) => {
    if (data.createGoods.isSucceed) {
      toast.success('Created successfully');
      router.push('/goods');
    } else {
      toast.error(data.createGoods.resultMessage);
    }
  },
  onError: (error) => {
    console.error('Failed:', error);
    toast.error('Creation failed');
  },
});
```

### 2.5 File Structure

```
src/graphql/
├── query/              # OMS queries/mutations
│   ├── goodsQuery.ts
│   └── orderQuery.ts
├── wmsQuery/           # WMS queries/mutations
├── __generated__/
│   ├── graphqlType.ts     # OMS types
│   └── wmsGraphqlType.ts  # WMS types
└── hooks/
    ├── goods/
    │   ├── query/
    │   │   └── useGetAllGoodsQuery.ts
    │   └── mutation/
    │       └── useCreateGoodsMutation.ts
    └── wms/
```

---

## 3. Frontend Design 4 Core Principles

### 3.1 Readability

**No magic numbers**
```typescript
// ❌ BAD
if (items.length > 3) { ... }

// ✅ GOOD
const MAX_VISIBLE_ITEMS = 3;
if (items.length > MAX_VISIBLE_ITEMS) { ... }
```

**Abstract complex conditions**
```typescript
// ❌ BAD
if (user.role === 'admin' || user.role === 'manager') { ... }

// ✅ GOOD
const canManageOrders = user.role === 'admin' || user.role === 'manager';
if (canManageOrders) { ... }
```

### 3.2 Predictability

**Consistent return types**
```typescript
// ❌ BAD
function getUser(id: string) {
  if (!id) return null;
  if (error) return undefined;
  return user;
}

// ✅ GOOD
function getUser(id: string): User | null {
  if (!id || error) return null;
  return user;
}
```

### 3.3 Cohesion

**Keep related functionality together**
```typescript
// ✅ OrderCard.tsx - all order card related code
interface OrderCardProps { ... }

const formatOrderDate = (date: string) => { ... };
const getOrderStatusColor = (status: OrderStatus) => { ... };

export function OrderCard({ order }: OrderCardProps) { ... }
```

### 3.4 Coupling

**Inject dependencies via Props**
```typescript
// ❌ BAD: Global dependency
export function OrderList() {
  const user = useUser();  // Global dependency
  return <div>{user.orders.map(...)}</div>;
}

// ✅ GOOD: Dependency injection
export function OrderList({ orders }: { orders: Order[] }) {
  return <div>{orders.map(...)}</div>;
}
```

---

## 4. Code Review Checklist

Always verify after writing code:

- [ ] **Clean Code**: Readability, simplicity, clarity
- [ ] **Declarative Naming**: Names reveal intent
- [ ] **Component Export**: Named export (default only for pages)
- [ ] **Business Logic**: Abstracted to custom hooks
- [ ] **Type Safety**: No `any` usage
- [ ] **GraphQL Patterns**: Naming, hooks, types, error handling
- [ ] **Props Depth**: Context API if ≥4 levels
- [ ] **Destructuring**: Object/array destructuring used
- [ ] **File Lines**: Under 500 lines
- [ ] **Coupling/Cohesion**: Low coupling, high cohesion

---

## 5. Bug Fixing Process

### Phase 1: Exploration & Analysis
1. Collect error messages and stack traces
2. Find files where error occurs
3. Check recent changes (git log, git diff)
4. Understand data flow

### Phase 2: Planning
1. Identify root cause
2. Form hypothesis
3. Plan minimal fix
4. Consider side effects

### Phase 3: Execution
1. Apply targeted fix
2. Test locally
3. Add test cases
4. Document prevention methods

---

## 6. Business Logic Validation

### OMS-Specific Rules

**Order Status Transitions**
```typescript
const VALID_TRANSITIONS = {
  DRAFT: ['CONFIRMED', 'CANCELLED'],
  CONFIRMED: ['PROCESSING', 'CANCELLED'],
  PROCESSING: ['SHIPPED', 'CANCELLED'],
  SHIPPED: ['DELIVERED', 'RETURNED'],
  DELIVERED: ['COMPLETED', 'RETURNED'],
  CANCELLED: [],
  RETURNED: ['REFUNDED'],
  REFUNDED: [],
  COMPLETED: [],
};
```

**Price Calculation Order**
```typescript
function calculateOrderTotal(order: Order): number {
  let total = 0;

  // 1. Base product price
  for (const item of order.items) {
    total += item.price * item.quantity;
  }

  // 2. Item-level discounts
  total -= calculateItemDiscounts(order.items);

  // 3. Order-level discounts
  total -= calculateOrderDiscount(total);

  // 4. Shipping fee
  total += calculateShippingFee(order);

  // 5. Tax
  total += calculateTax(total);

  return Math.round(total);
}
```

---

## 7. PR/Commit Review Guide

### Check When Analyzing Git Diff

1. **React Patterns**
   - Hook dependency arrays correct?
   - No unnecessary re-renders?
   - Component composition appropriate?

2. **TypeScript Type Safety**
   - No `any` type usage?
   - Type definitions clear?

3. **GraphQL Patterns**
   - Naming conventions followed?
   - Using onCompleted/onError?
   - Cache updates appropriate?

4. **Performance**
   - useMemo/useCallback used appropriately?
   - Rendering optimized?

5. **Security**
   - Input validation present?
   - No XSS vulnerabilities?
   - No secrets exposed?

---

## 8. Code Generation Templates

### Component Template
```typescript
// src/components/order/OrderCard.tsx
interface OrderCardProps {
  order: Order;
  onEdit: () => void;
  onDelete: () => void;
}

export function OrderCard({ order, onEdit, onDelete }: OrderCardProps) {
  return (
    <div>
      <h3>{order.title}</h3>
      <button onClick={onEdit}>Edit</button>
      <button onClick={onDelete}>Delete</button>
    </div>
  );
}
```

### Custom Hook Template
```typescript
// src/graphql/hooks/goods/query/useGetAllGoodsQuery.ts
import { useQuery, QueryHookOptions } from '@apollo/client';
import { Query } from '@/graphql/__generated__/graphqlType';
import { GET_ALL_GOODS } from '@/graphql/query/goodsQuery';

type GetAllGoodsQuery = Pick<Query, 'getAllGoods'>;

export function useGetAllGoodsQuery(
  options?: QueryHookOptions<GetAllGoodsQuery>
) {
  return useQuery<GetAllGoodsQuery>(GET_ALL_GOODS, options);
}
```

### Context Template
```typescript
// src/contexts/OrderContext.tsx
interface OrderContextValue {
  orders: Order[];
  loading: boolean;
}

const OrderContext = createContext<OrderContextValue | null>(null);

export function OrderProvider({ children }: { children: ReactNode }) {
  const { data, loading } = useGetAllOrdersQuery();

  return (
    <OrderContext.Provider value={{ orders: data?.orders || [], loading }}>
      {children}
    </OrderContext.Provider>
  );
}

export function useOrderContext() {
  const context = useContext(OrderContext);
  if (!context) {
    throw new Error('useOrderContext must be used within OrderProvider');
  }
  return context;
}
```

---

## Critical Rules Summary

1. **ALL GraphQL queries/mutations MUST be in custom hooks**
2. **Error handling MUST use onCompleted/onError (NEVER try/catch)**
3. **Components MUST use export function (only pages use export default)**
4. **Business logic MUST be abstracted to custom hooks**
5. **Props depth ≥4 MUST use Context API**
6. **Files >500 lines MUST be split**
7. **Destructuring MUST be used by default**
8. **`any` type MUST be avoided**

---

Follow these rules to write **consistent, maintainable, and scalable code**.
